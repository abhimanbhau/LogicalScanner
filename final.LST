ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 1   


ARM COMPILER V2.41, COMPILATION OF MODULE final
OBJECT MODULE PLACED IN final.OBJ
COMPILER INVOKED BY: C:\Keil\ARM\BIN\CA.exe final.c THUMB BROWSE DEBUG TABS(4) 

stmt  level    source

    1          #include <stdio.h>
    2          #include "lpc214x.h"
    3          #include <string.h>
    4          #include <stdlib.h>
    5          //void segdisp(unsigned char );
    6          void wait_us (unsigned long);
    7          void GPIO_Port_Low(unsigned int);
    8          void GPIO_Port_High(unsigned int);
    9          void GPIO_Set_Port(unsigned int , unsigned int);
   10          void disp_cmd(unsigned char);
   11          void disp_write(unsigned char);
   12          void lcd_init(void);
   13          void Delay(void);
   14          #define DISP_FUNC 0x38 // sets the display to 4-bit, 2 lines, 5x7 chars + cursor-off
   15          #define DISP_ENTRY 0x06
   16          #define DISP_CNTL 0x08
   17          #define DISP_ON 0x04
   18          #define DISP_CURSOR 0x02
   19          #define DISP_CLEAR 0x01
   20          #define DISP_HOME 0x02
   21          #define DISP_POS 0x80
   22          #define DISP_BLINK 0x01
   23          #define DISPDATA_MASK 0x00ff0000  // four(!) bit data bus to the display panel connected to GPIO[12..15]
   24          #define ENABLE_MASK 1<<24 //toggal BIT for testing BY SP
   25          #define REGSEL_MASK 1<<25 //toggal BIT for testing BY SP
   26          
   27          // Abhiman Kolte
   28          //#define DELAY_TWO xxxxx
   29          
   30          
   31          void Delay(void)
   32          {
   33   1          unsigned int i,j;
   34   1          for(i=0; i<2000; i++)
   35   1              for(j=0; j<1234; j++);
   36   1      }
   37          
   38          void Delay2(void)
   39          {
   40   1          unsigned int i,j;
   41   1          for(i=0; i<400; i++)
   42   1              for(j=0; j<1234; j++);
   43   1      }
   44          
   45          void wait_us (unsigned long usdelay )
   46          {
   47   1          static unsigned long i;
   48   1          usdelay=usdelay/0x10;
   49   1          for(i=0;i<=usdelay;i++)
   50   1          {}
   51   1      }
   52          void GPIO_Port_Low(unsigned int value)
   53          {
   54   1          IO1CLR = value; // clear zeros'
   55   1          wait_us(1); // slow down timing for LCD compatibility
   56   1      }
   57          void GPIO_Port_High(unsigned int value){
   58   1          IO1SET = value; // set ones'
   59   1          wait_us(1); // slow down timing for LCD compatibility
ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 2   

   60   1      }
   61          void GPIO_Set_Port(unsigned int mask, unsigned int value)
   62          {
   63   1          IO1SET = mask & value; // set ones'
   64   1          IO1CLR = mask & (~value); // clear zeros'
   65   1          wait_us(1); // slow down timing for LCD compatibility
   66   1      }
   67          void disp_cmd(unsigned char cmd)
   68          {
   69   1          IO1DIR = (IO1DIR | DISPDATA_MASK | REGSEL_MASK | ENABLE_MASK); // set ports to outputs
   70   1          GPIO_Set_Port(DISPDATA_MASK, cmd<<16); // latch the command
   71   1          GPIO_Port_Low(REGSEL_MASK); // select the command reg = 0
   72   1          wait_us(1);
   73   1          GPIO_Port_High(ENABLE_MASK); // latch the command into the LCD panel = 1 - first nibble
   74   1          wait_us(1);
   75   1          GPIO_Port_Low(ENABLE_MASK); // ENABLE=0;
   76   1          wait_us(1);
   77   1          //GPIO_Set_Port(DISPDATA_MASK, cmd <<20); // latch the command
   78   1          //wait_us(1);
   79   1          //GPIO_Port_High(ENABLE_MASK); // latch the command into the LCD panel = 1 - second nibble
   80   1          //wait_us(1);
   81   1          //GPIO_Port_Low(ENABLE_MASK); // ENABLE=0;
   82   1      }
   83          void disp_write(unsigned char value)
   84          {
   85   1          IO1DIR = IO1DIR | DISPDATA_MASK | REGSEL_MASK | ENABLE_MASK; // select write mode RDWR=0
   86   1          GPIO_Set_Port(DISPDATA_MASK, value<<16); // latch the data upper nibble
   87   1          GPIO_Port_High(REGSEL_MASK); // select the command reg = 1 select data reg
   88   1          wait_us(1);
   89   1          GPIO_Port_High(ENABLE_MASK); // latch the command into the LCD panel = 1
   90   1          wait_us(1);
   91   1          GPIO_Port_Low(ENABLE_MASK); // ENABLE=0;
   92   1          wait_us(1);
   93   1          // GPIO_Set_Port(DISPDATA_MASK, value <<20); // latch the data lower nibble
   94   1          //wait_us(1);
   95   1          //GPIO_Port_High(ENABLE_MASK); // latch the command into the LCD panel = 1
   96   1          //wait_us(1);
   97   1          //GPIO_Port_Low(ENABLE_MASK); // ENABLE=0;
   98   1      }
   99          void lcd_init(void) {
  100   1          unsigned char counter;
  101   1          IO1DIR = IO1DIR | DISPDATA_MASK | REGSEL_MASK |ENABLE_MASK;  // select port direction=output
  102   1          wait_us(20000); // wait for LCD to reset itself
  103   1          for(counter = 0; counter <3; counter++){
  104   2              GPIO_Set_Port(DISPDATA_MASK, (0x00020000)); // latch the command 0x30
  105   2              GPIO_Port_Low(REGSEL_MASK); // select the command reg REGSEL=0
  106   2              wait_us(1);
  107   2              GPIO_Port_High(ENABLE_MASK); // latch the command into the LCD panel = 1
  108   2              wait_us(1);
  109   2              GPIO_Port_Low(ENABLE_MASK); // latch the command into the LCD panel ENABLE=0
  110   2              wait_us(5000); // wait for LCD
  111   2          }
  112   1          disp_cmd(DISP_FUNC); // set the display for an 8
  113   1          wait_us(5000); // wait for LCD
  114   1          disp_cmd(DISP_CNTL | DISP_ON ); // turn the display on, cursor off
  115   1          wait_us(5000); // wait for LCD
  116   1          /*********************Added Function **************************************/
  117   1          disp_cmd(0x14);
  118   1          wait_us(5000);
  119   1          disp_cmd(DISP_CLEAR); // clear the display
  120   1          wait_us(5000); // wait for LCD
  121   1          disp_cmd(DISP_ENTRY); // set the character entry
  122   1          // mode to increment display
  123   1          // address for each
  124   1          // character, but not to scroll
  125   1          wait_us(5000);
ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 3   

  126   1      }
  127          void display(unsigned char arr[])
  128          {
  129   1          int i=0;
  130   1          int size = sizeof(arr);
  131   1          disp_cmd(0x80);
  132   1          wait_us(5000);
  133   1          for(i=0;i<10;i++)
  134   1          {
  135   2              if(arr[i])
  136   2              {
  137   3                  disp_write(arr[i]);
  138   3                  wait_us(5000);
  139   3              }
  140   2              else
  141   2              return;
  142   2          }
  143   1      }
  144          // abhiman kolte
  145          char hex2char(unsigned char arr[])
  146          {
  147   1          int num = atoi(arr);
  148   1          if(num <= 100)
  149   1              return 'A';
  150   1          else if(num <= 200)
  151   1              return 'B';
  152   1          else if(num <= 300)
  153   1              return 'C';
  154   1          else if(num <= 400)
  155   1              return 'D';
  156   1          else if(num <= 500)
  157   1              return 'E';
  158   1          else if(num <= 600)
  159   1              return 'F';
  160   1          else if(num <= 700)
  161   1              return 'G'; 
  162   1          else if(num <= 800)
  163   1              return 'H';
  164   1          else if(num <= 900)
  165   1              return 'I'; 
  166   1          else if(num <= 1000)
  167   1              return 'J';
  168   1          else if(num <= 1100)
  169   1              return 'K';
  170   1          else if(num <= 1200)
  171   1              return 'L';
  172   1          else if(num <= 1300)
  173   1              return 'M';
  174   1          else if(num <= 1400)
  175   1              return 'N';
  176   1          else if(num <= 1500)
  177   1              return 'O';
  178   1          else if(num <= 1600)
  179   1              return 'P';
  180   1          else if(num <= 1700)
  181   1              return 'Q';
  182   1          else if(num <= 1800)
  183   1              return 'R';
  184   1          else if(num <= 1900)
  185   1              return 'S'; 
  186   1          else if(num <= 2000)
  187   1              return 'T'; 
  188   1          else if(num <= 2100)
  189   1              return 'U';
  190   1          else if(num <= 2200)
  191   1              return 'V';
ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 4   

  192   1          else if(num <= 2300)
  193   1              return 'W';
  194   1          else if(num <= 2400)
  195   1              return 'X';
  196   1          else if(num <= 2500)
  197   1              return 'Y';
  198   1          else if(num <= 2600)
  199   1              return 'Z';
  200   1          else if(num <= 2700)
  201   1              return '1';
  202   1          else if(num <= 2800)
  203   1              return '2';
  204   1          else if(num <= 3000)
  205   1              return '3';
  206   1          else 
  207   1              return '#';
  208   1      }
  209          
  210          int main(void)
  211          {
  212   1          int i, counter = 10;
  213   1          unsigned int value; unsigned char d_hex[4];
  214   1          char vals[10];
  215   1          PINSEL0=0X00000C00;
  216   1          lcd_init();
  217   1          display(".........");
  218   1          display("SCN_START");
  219   1          Delay();
  220   1          Delay();
  221   1          while(counter)
  222   1          {
  223   2              Delay();
  224   2              //wait_us2(DELAY_TWO);
  225   2              AD0CR=0X01200680;//select chnl1,divide pclk by 06+1,burst controlled by software,
  226   2              //10clks 9bits,a/d on operational mode,start conversion on rising edge.
  227   2              do
  228   2              {
  229   3                  value=AD0DR7;
  230   3              }while(value & 0x80000000 );//wait for the conversion done bit to be 1
  231   2              value=((value >>6)& 0x3ff );//
  232   2              value= (value * 3300)/0x3ff;//
  233   2              i=3;
  234   2              while(i>=0)
  235   2              {
  236   3                  d_hex[i]=(value%10)+48;
  237   3                  value=value/10;
  238   3                  i--;
  239   3              }
  240   2              //val_array[counter] = d_hex;
  241   2              vals[counter - 1] = hex2char(& d_hex[0]);
  242   2              //display(& d_hex[0]);
  243   2              //hex2char(& d_hex[0]);
  244   2              //wait_us(500);
  245   2              counter--;
  246   2              Delay2();
  247   2          }
  248   1          display("SCN_COMPL");
  249   1          Delay();
  250   1          Delay();
  251   1          Delay();
  252   1          display(vals);
  253   1          return 0;
  254   1      }ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 5   

ASSEMBLY LISTING OF GENERATED OBJECT CODE



*** EXTERNALS:
 EXTERN CODE16 (atoi?T)
 EXTERN NUMBER (__startup)
 EXTERN CODE16 (?C?UDIV?T)



*** PUBLICS:
 PUBLIC         wait_us?T
 PUBLIC         GPIO_Port_Low?T
 PUBLIC         GPIO_Port_High?T
 PUBLIC         GPIO_Set_Port?T
 PUBLIC         disp_cmd?T
 PUBLIC         disp_write?T
 PUBLIC         lcd_init?T
 PUBLIC         Delay?T
 PUBLIC         Delay2?T
 PUBLIC         display?T
 PUBLIC         hex2char?T
 PUBLIC         main



*** DATA SEGMENT '?CON?final':
 00000000          ??S_3:
 00000000            DB          'SCN_COMPL',0x00
 0000000A          ??S_2:
 0000000A            DB          'SCN_START',0x00
 00000014          ??S_1:
 00000014            DB          '.........',0x00

*** DATA SEGMENT '?DT0?final':
 00000000          i:
 00000000            DS          4



*** CODE SEGMENT '?PR?Delay?T?final':
   32: {
 00000000            ; SCOPE-START
   34:     for(i=0; i<2000; i++)
 00000000  2000      MOV         R0,#0x0
 00000002  ---- Variable 'i' assigned to Register 'R0' ----
   35:         for(j=0; j<1234; j++);
 00000002          L_10:
 00000002  2100      MOV         R1,#0x0
 00000004  ---- Variable 'j' assigned to Register 'R1' ----
 00000004          L_6:
 00000004  3101      ADD         R1,#0x1
 00000006  1C0A      MOV         R2,R1 ; j
 00000008  4800      LDR         R3,=0x4D2
 0000000A  429A      CMP         R2,R3 ; j
 0000000C  D3FA      BCC         L_6  ; T=0x00000004
 0000000E  3001      ADD         R0,#0x1
 00000010  1C01      MOV         R1,R0 ; i
 00000012  4800      LDR         R2,=0x7D0
 00000014  4291      CMP         R1,R2 ; i
 00000016  D3F4      BCC         L_10  ; T=0x00000002
 00000018            ; SCOPE-END
   36: }
 00000018  4770      BX          R14
 0000001A          ENDP ; 'Delay?T'


*** CODE SEGMENT '?PR?Delay2?T?final':
   39: {
 00000000            ; SCOPE-START
   41:     for(i=0; i<400; i++)
 00000000  2000      MOV         R0,#0x0
 00000002  ---- Variable 'i' assigned to Register 'R0' ----
   42:         for(j=0; j<1234; j++);
 00000002          L_20:
ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 6   

 00000002  2100      MOV         R1,#0x0
 00000004  ---- Variable 'j' assigned to Register 'R1' ----
 00000004          L_16:
 00000004  3101      ADD         R1,#0x1
 00000006  1C0A      MOV         R2,R1 ; j
 00000008  4800      LDR         R3,=0x4D2
 0000000A  429A      CMP         R2,R3 ; j
 0000000C  D3FA      BCC         L_16  ; T=0x00000004
 0000000E  3001      ADD         R0,#0x1
 00000010  1C01      MOV         R1,R0 ; i
 00000012  4A64      LDR         R2,=0x190
 00000014  4291      CMP         R1,R2 ; i
 00000016  D3F4      BCC         L_20  ; T=0x00000002
 00000018            ; SCOPE-END
   43: }
 00000018  4770      BX          R14
 0000001A          ENDP ; 'Delay2?T'


*** CODE SEGMENT '?PR?wait_us?T?final':
   45: void wait_us (unsigned long usdelay )
 00000000  ---- Variable 'usdelay' assigned to Register 'R0' ----
   48:     usdelay=usdelay/0x10;
 00000000  0900      LSR         R0,R0,#0x4 ; usdelay
   49:     for(i=0;i<=usdelay;i++)
 00000002  2200      MOV         R2,#0x0
 00000004  4800      LDR         R1,=i ; i
 00000006  600A      STR         R2,[R1,#0x0] ; i
 00000008  E003      B           L_23  ; T=0x00000012
   50:     {}
 0000000A          L_21:
 0000000A  4800      LDR         R1,=i ; i
 0000000C  680A      LDR         R2,[R1,#0x0] ; i
 0000000E  3201      ADD         R2,#0x1
 00000010  600A      STR         R2,[R1,#0x0] ; i
 00000012          L_23:
 00000012  1C02      MOV         R2,R0 ; usdelay
 00000014  4800      LDR         R1,=i ; i
 00000016  6809      LDR         R1,[R1,#0x0] ; i
 00000018  4291      CMP         R1,R2 ; usdelay
 0000001A  D9F6      BLS         L_21  ; T=0x0000000A
   51: }
 0000001C  4770      BX          R14
 0000001E          ENDP ; 'wait_us?T'


*** CODE SEGMENT '?PR?GPIO_Port_Low?T?final':
   52: void GPIO_Port_Low(unsigned int value)
 00000000  B500      PUSH        {LR}
 00000002  ---- Variable 'value' assigned to Register 'R0' ----
   54:     IO1CLR = value; // clear zeros'
 00000002  1C01      MOV         R1,R0 ; value
 00000004  4800      LDR         R0,=0xE002801C
 00000006  6001      STR         R1,[R0,#0x0]
   55:     wait_us(1); // slow down timing for LCD compatibility
 00000008  2001      MOV         R0,#0x1
 0000000A  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          wait_us?T  ; T=0x0001  (2)
   56: }
 0000000E  BC08      POP         {R3}
 00000010  4718      BX          R3
 00000012          ENDP ; 'GPIO_Port_Low?T'


*** CODE SEGMENT '?PR?GPIO_Port_High?T?final':
   57: void GPIO_Port_High(unsigned int value){
 00000000  B500      PUSH        {LR}
 00000002  ---- Variable 'value' assigned to Register 'R0' ----
   58:     IO1SET = value; // set ones'
 00000002  1C01      MOV         R1,R0 ; value
 00000004  4800      LDR         R0,=0xE0028014
 00000006  6001      STR         R1,[R0,#0x0]
ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 7   

   59:     wait_us(1); // slow down timing for LCD compatibility
 00000008  2001      MOV         R0,#0x1
 0000000A  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          wait_us?T  ; T=0x0001  (2)
   60: }
 0000000E  BC08      POP         {R3}
 00000010  4718      BX          R3
 00000012          ENDP ; 'GPIO_Port_High?T'


*** CODE SEGMENT '?PR?GPIO_Set_Port?T?final':
   61: void GPIO_Set_Port(unsigned int mask, unsigned int value)
 00000000  B500      PUSH        {LR}
 00000002  1C0B      MOV         R3,R1 ; value
 00000004  ---- Variable 'value' assigned to Register 'R3' ----
 00000004  ---- Variable 'mask' assigned to Register 'R0' ----
   63:     IO1SET = mask & value; // set ones'
 00000004  1C19      MOV         R1,R3 ; value
 00000006  1C02      MOV         R2,R0 ; mask
 00000008  400A      AND         R2,R1 ; value
 0000000A  4800      LDR         R1,=0xE0028014
 0000000C  600A      STR         R2,[R1,#0x0]
   64:     IO1CLR = mask & (~value); // clear zeros'
 0000000E  1C1A      MOV         R2,R3 ; value
 00000010  1C01      MOV         R1,R0 ; mask
 00000012  4391      BIC         R1,R2 ; value
 00000014  4800      LDR         R0,=0xE002801C
 00000016  6001      STR         R1,[R0,#0x0]
   65:     wait_us(1); // slow down timing for LCD compatibility
 00000018  2001      MOV         R0,#0x1
 0000001A  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 0000001C  FFF1      BL          wait_us?T  ; T=0x0001  (2)
   66: }
 0000001E  BC08      POP         {R3}
 00000020  4718      BX          R3
 00000022          ENDP ; 'GPIO_Set_Port?T'


*** CODE SEGMENT '?PR?disp_cmd?T?final':
   67: void disp_cmd(unsigned char cmd)
 00000000  B500      PUSH        {LR}
 00000002  1C01      MOV         R1,R0 ; cmd
 00000004  ---- Variable 'cmd' assigned to Register 'R1' ----
   69:     IO1DIR = (IO1DIR | DISPDATA_MASK | REGSEL_MASK | ENABLE_MASK); // set ports to outputs
 00000004  4800      LDR         R0,=0xE0028018
 00000006  6802      LDR         R2,[R0,#0x0]
 00000008  4800      LDR         R0,=0x3FF0000
 0000000A  4302      ORR         R2,R0
 0000000C  4800      LDR         R0,=0xE0028018
 0000000E  6002      STR         R2,[R0,#0x0]
   70:     GPIO_Set_Port(DISPDATA_MASK, cmd<<16); // latch the command
 00000010  1C08      MOV         R0,R1 ; cmd
 00000012  0601      LSL         R1,R0,#0x18 ; cmd
 00000014  0E09      LSR         R1,R1,#0x18
 00000016  0409      LSL         R1,R1,#0x10
 00000018  4800      LDR         R0,=0xFF0000
 0000001A  F7FF      BL          GPIO_Set_Port?T  ; T=0x0001  (1)
 0000001C  FFF1      BL          GPIO_Set_Port?T  ; T=0x0001  (2)
   71:     GPIO_Port_Low(REGSEL_MASK); // select the command reg = 0
 0000001E  4800      LDR         R0,=0x2000000
 00000020  F7FF      BL          GPIO_Port_Low?T  ; T=0x0001  (1)
 00000022  FFEE      BL          GPIO_Port_Low?T  ; T=0x0001  (2)
   72:     wait_us(1);
 00000024  2001      MOV         R0,#0x1
 00000026  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000028  FFEB      BL          wait_us?T  ; T=0x0001  (2)
   73:     GPIO_Port_High(ENABLE_MASK); // latch the command into the LCD panel = 1 - first nibble
 0000002A  4800      LDR         R0,=0x1000000
 0000002C  F7FF      BL          GPIO_Port_High?T  ; T=0x0001  (1)
 0000002E  FFE8      BL          GPIO_Port_High?T  ; T=0x0001  (2)
ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 8   

   74:     wait_us(1);
 00000030  2001      MOV         R0,#0x1
 00000032  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000034  FFE5      BL          wait_us?T  ; T=0x0001  (2)
   75:     GPIO_Port_Low(ENABLE_MASK); // ENABLE=0;
 00000036  4800      LDR         R0,=0x1000000
 00000038  F7FF      BL          GPIO_Port_Low?T  ; T=0x0001  (1)
 0000003A  FFE2      BL          GPIO_Port_Low?T  ; T=0x0001  (2)
   76:     wait_us(1);
 0000003C  2001      MOV         R0,#0x1
 0000003E  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000040  FFDF      BL          wait_us?T  ; T=0x0001  (2)
   82: }
 00000042  BC08      POP         {R3}
 00000044  4718      BX          R3
 00000046          ENDP ; 'disp_cmd?T'


*** CODE SEGMENT '?PR?disp_write?T?final':
   83: void disp_write(unsigned char value)
 00000000  B500      PUSH        {LR}
 00000002  1C01      MOV         R1,R0 ; value
 00000004  ---- Variable 'value' assigned to Register 'R1' ----
   85:     IO1DIR = IO1DIR | DISPDATA_MASK | REGSEL_MASK | ENABLE_MASK; // select write mode RDWR=0
 00000004  4800      LDR         R0,=0xE0028018
 00000006  6802      LDR         R2,[R0,#0x0]
 00000008  4800      LDR         R0,=0x3FF0000
 0000000A  4302      ORR         R2,R0
 0000000C  4800      LDR         R0,=0xE0028018
 0000000E  6002      STR         R2,[R0,#0x0]
   86:     GPIO_Set_Port(DISPDATA_MASK, value<<16); // latch the data upper nibble
 00000010  1C08      MOV         R0,R1 ; value
 00000012  0601      LSL         R1,R0,#0x18 ; value
 00000014  0E09      LSR         R1,R1,#0x18
 00000016  0409      LSL         R1,R1,#0x10
 00000018  4800      LDR         R0,=0xFF0000
 0000001A  F7FF      BL          GPIO_Set_Port?T  ; T=0x0001  (1)
 0000001C  FFF1      BL          GPIO_Set_Port?T  ; T=0x0001  (2)
   87:     GPIO_Port_High(REGSEL_MASK); // select the command reg = 1 select data reg
 0000001E  4800      LDR         R0,=0x2000000
 00000020  F7FF      BL          GPIO_Port_High?T  ; T=0x0001  (1)
 00000022  FFEE      BL          GPIO_Port_High?T  ; T=0x0001  (2)
   88:     wait_us(1);
 00000024  2001      MOV         R0,#0x1
 00000026  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000028  FFEB      BL          wait_us?T  ; T=0x0001  (2)
   89:     GPIO_Port_High(ENABLE_MASK); // latch the command into the LCD panel = 1
 0000002A  4800      LDR         R0,=0x1000000
 0000002C  F7FF      BL          GPIO_Port_High?T  ; T=0x0001  (1)
 0000002E  FFE8      BL          GPIO_Port_High?T  ; T=0x0001  (2)
   90:     wait_us(1);
 00000030  2001      MOV         R0,#0x1
 00000032  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000034  FFE5      BL          wait_us?T  ; T=0x0001  (2)
   91:     GPIO_Port_Low(ENABLE_MASK); // ENABLE=0;
 00000036  4800      LDR         R0,=0x1000000
 00000038  F7FF      BL          GPIO_Port_Low?T  ; T=0x0001  (1)
 0000003A  FFE2      BL          GPIO_Port_Low?T  ; T=0x0001  (2)
   92:     wait_us(1);
 0000003C  2001      MOV         R0,#0x1
 0000003E  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000040  FFDF      BL          wait_us?T  ; T=0x0001  (2)
   98: }
 00000042  BC08      POP         {R3}
 00000044  4718      BX          R3
 00000046          ENDP ; 'disp_write?T'


*** CODE SEGMENT '?PR?lcd_init?T?final':
   99: void lcd_init(void) {
ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 9   

 00000000  B510      PUSH        {R4,LR}
 00000002            ; SCOPE-START
  101:     IO1DIR = IO1DIR | DISPDATA_MASK | REGSEL_MASK |ENABLE_MASK;  // select port direction=output
 00000002  4800      LDR         R0,=0xE0028018
 00000004  6801      LDR         R1,[R0,#0x0]
 00000006  4800      LDR         R0,=0x3FF0000
 00000008  4301      ORR         R1,R0
 0000000A  4800      LDR         R0,=0xE0028018
 0000000C  6001      STR         R1,[R0,#0x0]
  102:     wait_us(20000); // wait for LCD to reset itself
 0000000E  4800      LDR         R0,=0x4E20
 00000010  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000012  FFF6      BL          wait_us?T  ; T=0x0001  (2)
  103:     for(counter = 0; counter <3; counter++){
 00000014  2400      MOV         R4,#0x0
 00000016  ---- Variable 'counter' assigned to Register 'R4' ----
 00000016  E018      B           L_28  ; T=0x0000004A
 00000018          L_29:
  104:         GPIO_Set_Port(DISPDATA_MASK, (0x00020000)); // latch the command 0x30
 00000018  4800      LDR         R0,=0xFF0000
 0000001A  4800      LDR         R1,=0x20000
 0000001C  F7FF      BL          GPIO_Set_Port?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          GPIO_Set_Port?T  ; T=0x0001  (2)
  105:         GPIO_Port_Low(REGSEL_MASK); // select the command reg REGSEL=0
 00000020  4800      LDR         R0,=0x2000000
 00000022  F7FF      BL          GPIO_Port_Low?T  ; T=0x0001  (1)
 00000024  FFED      BL          GPIO_Port_Low?T  ; T=0x0001  (2)
  106:         wait_us(1);
 00000026  2001      MOV         R0,#0x1
 00000028  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 0000002A  FFEA      BL          wait_us?T  ; T=0x0001  (2)
  107:         GPIO_Port_High(ENABLE_MASK); // latch the command into the LCD panel = 1
 0000002C  4800      LDR         R0,=0x1000000
 0000002E  F7FF      BL          GPIO_Port_High?T  ; T=0x0001  (1)
 00000030  FFE7      BL          GPIO_Port_High?T  ; T=0x0001  (2)
  108:         wait_us(1);
 00000032  2001      MOV         R0,#0x1
 00000034  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000036  FFE4      BL          wait_us?T  ; T=0x0001  (2)
  109:         GPIO_Port_Low(ENABLE_MASK); // latch the command into the LCD panel ENABLE=0
 00000038  4800      LDR         R0,=0x1000000
 0000003A  F7FF      BL          GPIO_Port_Low?T  ; T=0x0001  (1)
 0000003C  FFE1      BL          GPIO_Port_Low?T  ; T=0x0001  (2)
  110:         wait_us(5000); // wait for LCD
 0000003E  4800      LDR         R0,=0x1388
 00000040  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000042  FFDE      BL          wait_us?T  ; T=0x0001  (2)
  111:     }
 00000044  3401      ADD         R4,#0x1
 00000046  0624      LSL         R4,R4,#0x18
 00000048  0E24      LSR         R4,R4,#0x18
 0000004A          L_28:
 0000004A  1C20      MOV         R0,R4 ; counter
 0000004C  0600      LSL         R0,R0,#0x18 ; counter
 0000004E  0E00      LSR         R0,R0,#0x18
 00000050  2803      CMP         R0,#0x3
 00000052  DBE1      BLT         L_29  ; T=0x00000018
  112:     disp_cmd(DISP_FUNC); // set the display for an 8
 00000054  2038      MOV         R0,#0x38
 00000056  F7FF      BL          disp_cmd?T  ; T=0x0001  (1)
 00000058  FFD3      BL          disp_cmd?T  ; T=0x0001  (2)
  113:     wait_us(5000); // wait for LCD
 0000005A  4800      LDR         R0,=0x1388
 0000005C  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 0000005E  FFD0      BL          wait_us?T  ; T=0x0001  (2)
  114:     disp_cmd(DISP_CNTL | DISP_ON ); // turn the display on, cursor off
ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 10  

 00000060  200C      MOV         R0,#0xC
 00000062  F7FF      BL          disp_cmd?T  ; T=0x0001  (1)
 00000064  FFCD      BL          disp_cmd?T  ; T=0x0001  (2)
  115:     wait_us(5000); // wait for LCD
 00000066  4800      LDR         R0,=0x1388
 00000068  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 0000006A  FFCA      BL          wait_us?T  ; T=0x0001  (2)
  117:     disp_cmd(0x14);
 0000006C  2014      MOV         R0,#0x14
 0000006E  F7FF      BL          disp_cmd?T  ; T=0x0001  (1)
 00000070  FFC7      BL          disp_cmd?T  ; T=0x0001  (2)
  118:     wait_us(5000);
 00000072  4800      LDR         R0,=0x1388
 00000074  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000076  FFC4      BL          wait_us?T  ; T=0x0001  (2)
  119:     disp_cmd(DISP_CLEAR); // clear the display
 00000078  2001      MOV         R0,#0x1
 0000007A  F7FF      BL          disp_cmd?T  ; T=0x0001  (1)
 0000007C  FFC1      BL          disp_cmd?T  ; T=0x0001  (2)
  120:     wait_us(5000); // wait for LCD
 0000007E  4800      LDR         R0,=0x1388
 00000080  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000082  FFBE      BL          wait_us?T  ; T=0x0001  (2)
  121:     disp_cmd(DISP_ENTRY); // set the character entry
 00000084  2006      MOV         R0,#0x6
 00000086  F7FF      BL          disp_cmd?T  ; T=0x0001  (1)
 00000088  FFBB      BL          disp_cmd?T  ; T=0x0001  (2)
  125:     wait_us(5000);
 0000008A  4800      LDR         R0,=0x1388
 0000008C  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 0000008E  FFB8      BL          wait_us?T  ; T=0x0001  (2)
 00000090            ; SCOPE-END
  126: }
 00000090  BC10      POP         {R4}
 00000092  BC08      POP         {R3}
 00000094  4718      BX          R3
 00000096          ENDP ; 'lcd_init?T'


*** CODE SEGMENT '?PR?display?T?final':
  127: void display(unsigned char arr[])
 00000000  B530      PUSH        {R4-R5,LR}
 00000002  1C05      MOV         R5,R0 ; arr
 00000004  ---- Variable 'arr' assigned to Register 'R5' ----
  128: {
 00000004            ; SCOPE-START
  129:     int i=0;
 00000004  2400      MOV         R4,#0x0
 00000006  ---- Variable 'i' assigned to Register 'R4' ----
  131:     disp_cmd(0x80);
 00000006  2080      MOV         R0,#0x80
 00000008  F7FF      BL          disp_cmd?T  ; T=0x0001  (1)
 0000000A  FFFA      BL          disp_cmd?T  ; T=0x0001  (2)
  132:     wait_us(5000);
 0000000C  4800      LDR         R0,=0x1388
 0000000E  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000010  FFF7      BL          wait_us?T  ; T=0x0001  (2)
  133:     for(i=0;i<10;i++)
 00000012  2400      MOV         R4,#0x0
 00000014          L_34:
  135:         if(arr[i])
 00000014  1C21      MOV         R1,R4 ; i
 00000016  1C28      MOV         R0,R5 ; arr
 00000018  5C40      LDRB        R0,[R0,R1]
 0000001A  2800      CMP         R0,#0x0
 0000001C  D008      BEQ         L_38  ; T=0x00000030
  137:             disp_write(arr[i]);
 0000001E  F7FF      BL          disp_write?T  ; T=0x0001  (1)
ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 11  

 00000020  FFEF      BL          disp_write?T  ; T=0x0001  (2)
  138:             wait_us(5000);
 00000022  4800      LDR         R0,=0x1388
 00000024  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000026  FFEC      BL          wait_us?T  ; T=0x0001  (2)
  142:     }
 00000028  3401      ADD         R4,#0x1
 0000002A  1C20      MOV         R0,R4 ; i
 0000002C  280A      CMP         R0,#0xA ; i
 0000002E  DBF1      BLT         L_34  ; T=0x00000014
 00000030            ; SCOPE-END
  143: }
 00000030          L_38:
 00000030  BC30      POP         {R4-R5}
 00000032  BC08      POP         {R3}
 00000034  4718      BX          R3
 00000036          ENDP ; 'display?T'


*** CODE SEGMENT '?PR?hex2char?T?final':
  145: char hex2char(unsigned char arr[])
 00000000  B500      PUSH        {LR}
 00000002  1C01      MOV         R1,R0 ; arr
 00000004  ---- Variable 'arr' assigned to Register 'R1' ----
  146: {
 00000004            ; SCOPE-START
  147:     int num = atoi(arr);
 00000004  1C08      MOV         R0,R1 ; arr
 00000006  F7FF      BL          atoi?T  ; T=0x0001  (1)
 00000008  FFFB      BL          atoi?T  ; T=0x0001  (2)
 0000000A  1C02      MOV         R2,R0 ; num
 0000000C  ---- Variable 'num' assigned to Register 'R2' ----
  148:     if(num <= 100)
 0000000C  1C10      MOV         R0,R2 ; num
 0000000E  2864      CMP         R0,#0x64 ; num
 00000010  DC01      BGT         L_39  ; T=0x00000016
  149:         return 'A';
 00000012  2041      MOV         R0,#0x41
 00000014  E0A7      B           L_40  ; T=0x00000166
 00000016          L_39:
  150:     else if(num <= 200)
 00000016  1C10      MOV         R0,R2 ; num
 00000018  28C8      CMP         R0,#0xC8 ; num
 0000001A  DC01      BGT         L_42  ; T=0x00000020
  151:         return 'B';
 0000001C  2042      MOV         R0,#0x42
 0000001E  E0A2      B           L_40  ; T=0x00000166
 00000020          L_42:
  152:     else if(num <= 300)
 00000020  1C10      MOV         R0,R2 ; num
 00000022  494B      LDR         R1,=0x12C
 00000024  4288      CMP         R0,R1 ; num
 00000026  DC01      BGT         L_44  ; T=0x0000002C
  153:         return 'C';
 00000028  2043      MOV         R0,#0x43
 0000002A  E09C      B           L_40  ; T=0x00000166
 0000002C          L_44:
  154:     else if(num <= 400)
 0000002C  1C10      MOV         R0,R2 ; num
 0000002E  4964      LDR         R1,=0x190
 00000030  4288      CMP         R0,R1 ; num
 00000032  DC01      BGT         L_46  ; T=0x00000038
  155:         return 'D';
 00000034  2044      MOV         R0,#0x44
 00000036  E096      B           L_40  ; T=0x00000166
 00000038          L_46:
  156:     else if(num <= 500)
 00000038  1C10      MOV         R0,R2 ; num
ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 12  

 0000003A  497D      LDR         R1,=0x1F4
 0000003C  4288      CMP         R0,R1 ; num
 0000003E  DC01      BGT         L_48  ; T=0x00000044
  157:         return 'E';
 00000040  2045      MOV         R0,#0x45
 00000042  E090      B           L_40  ; T=0x00000166
 00000044          L_48:
  158:     else if(num <= 600)
 00000044  1C10      MOV         R0,R2 ; num
 00000046  4996      LDR         R1,=0x258
 00000048  4288      CMP         R0,R1 ; num
 0000004A  DC01      BGT         L_50  ; T=0x00000050
  159:         return 'F';
 0000004C  2046      MOV         R0,#0x46
 0000004E  E08A      B           L_40  ; T=0x00000166
 00000050          L_50:
  160:     else if(num <= 700)
 00000050  1C10      MOV         R0,R2 ; num
 00000052  49AF      LDR         R1,=0x2BC
 00000054  4288      CMP         R0,R1 ; num
 00000056  DC01      BGT         L_52  ; T=0x0000005C
  161:         return 'G'; 
 00000058  2047      MOV         R0,#0x47
 0000005A  E084      B           L_40  ; T=0x00000166
 0000005C          L_52:
  162:     else if(num <= 800)
 0000005C  1C10      MOV         R0,R2 ; num
 0000005E  49C8      LDR         R1,=0x320
 00000060  4288      CMP         R0,R1 ; num
 00000062  DC01      BGT         L_54  ; T=0x00000068
  163:         return 'H';
 00000064  2048      MOV         R0,#0x48
 00000066  E07E      B           L_40  ; T=0x00000166
 00000068          L_54:
  164:     else if(num <= 900)
 00000068  1C10      MOV         R0,R2 ; num
 0000006A  49E1      LDR         R1,=0x384
 0000006C  4288      CMP         R0,R1 ; num
 0000006E  DC01      BGT         L_56  ; T=0x00000074
  165:         return 'I'; 
 00000070  2049      MOV         R0,#0x49
 00000072  E078      B           L_40  ; T=0x00000166
 00000074          L_56:
  166:     else if(num <= 1000)
 00000074  1C10      MOV         R0,R2 ; num
 00000076  49FA      LDR         R1,=0x3E8
 00000078  4288      CMP         R0,R1 ; num
 0000007A  DC01      BGT         L_58  ; T=0x00000080
  167:         return 'J';
 0000007C  204A      MOV         R0,#0x4A
 0000007E  E072      B           L_40  ; T=0x00000166
 00000080          L_58:
  168:     else if(num <= 1100)
 00000080  1C10      MOV         R0,R2 ; num
 00000082  4800      LDR         R1,=0x44C
 00000084  4288      CMP         R0,R1 ; num
 00000086  DC01      BGT         L_60  ; T=0x0000008C
  169:         return 'K';
 00000088  204B      MOV         R0,#0x4B
 0000008A  E06C      B           L_40  ; T=0x00000166
 0000008C          L_60:
  170:     else if(num <= 1200)
 0000008C  1C10      MOV         R0,R2 ; num
 0000008E  4800      LDR         R1,=0x4B0
 00000090  4288      CMP         R0,R1 ; num
 00000092  DC01      BGT         L_62  ; T=0x00000098
ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 13  

  171:         return 'L';
 00000094  204C      MOV         R0,#0x4C
 00000096  E066      B           L_40  ; T=0x00000166
 00000098          L_62:
  172:     else if(num <= 1300)
 00000098  1C10      MOV         R0,R2 ; num
 0000009A  4800      LDR         R1,=0x514
 0000009C  4288      CMP         R0,R1 ; num
 0000009E  DC01      BGT         L_64  ; T=0x000000A4
  173:         return 'M';
 000000A0  204D      MOV         R0,#0x4D
 000000A2  E060      B           L_40  ; T=0x00000166
 000000A4          L_64:
  174:     else if(num <= 1400)
 000000A4  1C10      MOV         R0,R2 ; num
 000000A6  4800      LDR         R1,=0x578
 000000A8  4288      CMP         R0,R1 ; num
 000000AA  DC01      BGT         L_66  ; T=0x000000B0
  175:         return 'N';
 000000AC  204E      MOV         R0,#0x4E
 000000AE  E05A      B           L_40  ; T=0x00000166
 000000B0          L_66:
  176:     else if(num <= 1500)
 000000B0  1C10      MOV         R0,R2 ; num
 000000B2  4800      LDR         R1,=0x5DC
 000000B4  4288      CMP         R0,R1 ; num
 000000B6  DC01      BGT         L_68  ; T=0x000000BC
  177:         return 'O';
 000000B8  204F      MOV         R0,#0x4F
 000000BA  E054      B           L_40  ; T=0x00000166
 000000BC          L_68:
  178:     else if(num <= 1600)
 000000BC  1C10      MOV         R0,R2 ; num
 000000BE  4800      LDR         R1,=0x640
 000000C0  4288      CMP         R0,R1 ; num
 000000C2  DC01      BGT         L_70  ; T=0x000000C8
  179:         return 'P';
 000000C4  2050      MOV         R0,#0x50
 000000C6  E04E      B           L_40  ; T=0x00000166
 000000C8          L_70:
  180:     else if(num <= 1700)
 000000C8  1C10      MOV         R0,R2 ; num
 000000CA  4800      LDR         R1,=0x6A4
 000000CC  4288      CMP         R0,R1 ; num
 000000CE  DC01      BGT         L_72  ; T=0x000000D4
  181:         return 'Q';
 000000D0  2051      MOV         R0,#0x51
 000000D2  E048      B           L_40  ; T=0x00000166
 000000D4          L_72:
  182:     else if(num <= 1800)
 000000D4  1C10      MOV         R0,R2 ; num
 000000D6  4800      LDR         R1,=0x708
 000000D8  4288      CMP         R0,R1 ; num
 000000DA  DC01      BGT         L_74  ; T=0x000000E0
  183:         return 'R';
 000000DC  2052      MOV         R0,#0x52
 000000DE  E042      B           L_40  ; T=0x00000166
 000000E0          L_74:
  184:     else if(num <= 1900)
 000000E0  1C10      MOV         R0,R2 ; num
 000000E2  4800      LDR         R1,=0x76C
 000000E4  4288      CMP         R0,R1 ; num
 000000E6  DC01      BGT         L_76  ; T=0x000000EC
  185:         return 'S'; 
 000000E8  2053      MOV         R0,#0x53
 000000EA  E03C      B           L_40  ; T=0x00000166
ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 14  

 000000EC          L_76:
  186:     else if(num <= 2000)
 000000EC  1C10      MOV         R0,R2 ; num
 000000EE  4800      LDR         R1,=0x7D0
 000000F0  4288      CMP         R0,R1 ; num
 000000F2  DC01      BGT         L_78  ; T=0x000000F8
  187:         return 'T'; 
 000000F4  2054      MOV         R0,#0x54
 000000F6  E036      B           L_40  ; T=0x00000166
 000000F8          L_78:
  188:     else if(num <= 2100)
 000000F8  1C10      MOV         R0,R2 ; num
 000000FA  4800      LDR         R1,=0x834
 000000FC  4288      CMP         R0,R1 ; num
 000000FE  DC01      BGT         L_80  ; T=0x00000104
  189:         return 'U';
 00000100  2055      MOV         R0,#0x55
 00000102  E030      B           L_40  ; T=0x00000166
 00000104          L_80:
  190:     else if(num <= 2200)
 00000104  1C10      MOV         R0,R2 ; num
 00000106  4800      LDR         R1,=0x898
 00000108  4288      CMP         R0,R1 ; num
 0000010A  DC01      BGT         L_82  ; T=0x00000110
  191:         return 'V';
 0000010C  2056      MOV         R0,#0x56
 0000010E  E02A      B           L_40  ; T=0x00000166
 00000110          L_82:
  192:     else if(num <= 2300)
 00000110  1C10      MOV         R0,R2 ; num
 00000112  4800      LDR         R1,=0x8FC
 00000114  4288      CMP         R0,R1 ; num
 00000116  DC01      BGT         L_84  ; T=0x0000011C
  193:         return 'W';
 00000118  2057      MOV         R0,#0x57
 0000011A  E024      B           L_40  ; T=0x00000166
 0000011C          L_84:
  194:     else if(num <= 2400)
 0000011C  1C10      MOV         R0,R2 ; num
 0000011E  4800      LDR         R1,=0x960
 00000120  4288      CMP         R0,R1 ; num
 00000122  DC01      BGT         L_86  ; T=0x00000128
  195:         return 'X';
 00000124  2058      MOV         R0,#0x58
 00000126  E01E      B           L_40  ; T=0x00000166
 00000128          L_86:
  196:     else if(num <= 2500)
 00000128  1C10      MOV         R0,R2 ; num
 0000012A  4800      LDR         R1,=0x9C4
 0000012C  4288      CMP         R0,R1 ; num
 0000012E  DC01      BGT         L_88  ; T=0x00000134
  197:         return 'Y';
 00000130  2059      MOV         R0,#0x59
 00000132  E018      B           L_40  ; T=0x00000166
 00000134          L_88:
  198:     else if(num <= 2600)
 00000134  1C10      MOV         R0,R2 ; num
 00000136  4800      LDR         R1,=0xA28
 00000138  4288      CMP         R0,R1 ; num
 0000013A  DC01      BGT         L_90  ; T=0x00000140
  199:         return 'Z';
 0000013C  205A      MOV         R0,#0x5A
 0000013E  E012      B           L_40  ; T=0x00000166
 00000140          L_90:
  200:     else if(num <= 2700)
 00000140  1C10      MOV         R0,R2 ; num
ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 15  

 00000142  4800      LDR         R1,=0xA8C
 00000144  4288      CMP         R0,R1 ; num
 00000146  DC01      BGT         L_92  ; T=0x0000014C
  201:         return '1';
 00000148  2031      MOV         R0,#0x31
 0000014A  E00C      B           L_40  ; T=0x00000166
 0000014C          L_92:
  202:     else if(num <= 2800)
 0000014C  1C10      MOV         R0,R2 ; num
 0000014E  4800      LDR         R1,=0xAF0
 00000150  4288      CMP         R0,R1 ; num
 00000152  DC01      BGT         L_94  ; T=0x00000158
  203:         return '2';
 00000154  2032      MOV         R0,#0x32
 00000156  E006      B           L_40  ; T=0x00000166
 00000158          L_94:
  204:     else if(num <= 3000)
 00000158  1C10      MOV         R0,R2 ; num
 0000015A  4800      LDR         R1,=0xBB8
 0000015C  4288      CMP         R0,R1 ; num
 0000015E  DC01      BGT         L_96  ; T=0x00000164
  205:         return '3';
 00000160  2033      MOV         R0,#0x33
 00000162  E000      B           L_40  ; T=0x00000166
 00000164          L_96:
  207:         return '#';
 00000164  2023      MOV         R0,#0x23
 00000166            ; SCOPE-END
  208: }
 00000166          L_40:
 00000166  BC08      POP         {R3}
 00000168  4718      BX          R3
 0000016A          ENDP ; 'hex2char?T'


*** CODE SEGMENT '?PR?main?final':
  210: int main(void)
 00000000  B500      PUSH        {LR}
 00000002  B084      SUB         R13,#0x10
  211: {
 00000004            ; SCOPE-START
  212:     int i, counter = 10;
 00000004  240A      MOV         R4,#0xA
 00000006  ---- Variable 'counter' assigned to Register 'R4' ----
  215:     PINSEL0=0X00000C00;
 00000006  4800      LDR         R1,=0xC00
 00000008  4800      LDR         R0,=0xE002C000
 0000000A  6001      STR         R1,[R0,#0x0]
  216:     lcd_init();
 0000000C  F7FF      BL          lcd_init?T  ; T=0x0001  (1)
 0000000E  FFF8      BL          lcd_init?T  ; T=0x0001  (2)
  217:     display(".........");
 00000010  4800      LDR         R0,=??S_1 ; ??S_1
 00000012  F7FF      BL          display?T  ; T=0x0001  (1)
 00000014  FFF5      BL          display?T  ; T=0x0001  (2)
  218:     display("SCN_START");
 00000016  4800      LDR         R0,=??S_2 ; ??S_2
 00000018  F7FF      BL          display?T  ; T=0x0001  (1)
 0000001A  FFF2      BL          display?T  ; T=0x0001  (2)
  219:     Delay();
 0000001C  F7FF      BL          Delay?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          Delay?T  ; T=0x0001  (2)
  220:     Delay();
 00000020  F7FF      BL          Delay?T  ; T=0x0001  (1)
 00000022  FFEE      BL          Delay?T  ; T=0x0001  (2)
  221:     while(counter)
 00000024          L_100:
  223:         Delay();
ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 16  

 00000024  F7FF      BL          Delay?T  ; T=0x0001  (1)
 00000026  FFEC      BL          Delay?T  ; T=0x0001  (2)
  225:         AD0CR=0X01200680;//select chnl1,divide pclk by 06+1,burst controlled by software,
 00000028  4800      LDR         R1,=0x1200680
 0000002A  4800      LDR         R0,=0xE0034000
 0000002C  6001      STR         R1,[R0,#0x0]
  227:         do
 0000002E          L_102:
  229:             value=AD0DR7;
 0000002E  4800      LDR         R0,=0xE003402C
 00000030  6806      LDR         R6,[R0,#0x0]
 00000032  ---- Variable 'value' assigned to Register 'R6' ----
  230:         }while(value & 0x80000000 );//wait for the conversion done bit to be 1
 00000032  1C30      MOV         R0,R6 ; value
 00000034  4800      LDR         R1,=0x80000000
 00000036  4208      TST         R0,R1 ; value
 00000038  D1F9      BNE         L_102  ; T=0x0000002E
  231:         value=((value >>6)& 0x3ff );//
 0000003A  09B6      LSR         R6,R6,#0x6 ; value
 0000003C  4800      LDR         R1,=0x3FF
 0000003E  400E      AND         R6,R1
  232:         value= (value * 3300)/0x3ff;//
 00000040  1C30      MOV         R0,R6 ; value
 00000042  4800      LDR         R2,=0xCE4
 00000044  4350      MUL         R0,R2
 00000046  F7FF      BL          ?C?UDIV?T  ; T=0x0001  (1) ; ?C?UDIV?T
 00000048  FFDB      BL          ?C?UDIV?T  ; T=0x0001  (2) ; ?C?UDIV?T
 0000004A  1C08      MOV         R0,R1
 0000004C  1C06      MOV         R6,R0 ; value
  233:         i=3;
 0000004E  2503      MOV         R5,#0x3
 00000050  ---- Variable 'i' assigned to Register 'R5' ----
  234:         while(i>=0)
 00000050          L_108:
  236:             d_hex[i]=(value%10)+48;
 00000050  1C30      MOV         R0,R6 ; value
 00000052  210A      MOV         R1,#0xA
 00000054  F7FF      BL          ?C?UDIV?T  ; T=0x0001  (1) ; ?C?UDIV?T
 00000056  FFD4      BL          ?C?UDIV?T  ; T=0x0001  (2) ; ?C?UDIV?T
 00000058  1C01      MOV         R1,R0
 0000005A  3030      ADD         R0,#0x30
 0000005C  0600      LSL         R0,R0,#0x18
 0000005E  0E00      LSR         R0,R0,#0x18
 00000060  1C2A      MOV         R2,R5 ; i
 00000062  A900      ADD         R1,R13,#0x0
 00000064  5488      STRB        R0,[R1,R2]
  237:             value=value/10;
 00000066  1C30      MOV         R0,R6 ; value
 00000068  210A      MOV         R1,#0xA
 0000006A  F7FF      BL          ?C?UDIV?T  ; T=0x0001  (1) ; ?C?UDIV?T
 0000006C  FFC9      BL          ?C?UDIV?T  ; T=0x0001  (2) ; ?C?UDIV?T
 0000006E  1C08      MOV         R0,R1
 00000070  1C06      MOV         R6,R0 ; value
  238:             i--;
 00000072  3D01      SUB         R5,#0x1
  239:         }
 00000074  1C28      MOV         R0,R5 ; i
 00000076  2800      CMP         R0,#0x0 ; i
 00000078  DAEA      BGE         L_108  ; T=0x00000050
  241:         vals[counter - 1] = hex2char(& d_hex[0]);
 0000007A  A800      ADD         R0,R13,#0x0
 0000007C  F7FF      BL          hex2char?T  ; T=0x0001  (1)
 0000007E  FFC0      BL          hex2char?T  ; T=0x0001  (2)
 00000080  1C22      MOV         R2,R4 ; counter
 00000082  2103      MOV         R1,#0x3
 00000084  4469      ADD         R1,R13
ARM COMPILER V2.41,  final                                                                 01/05/16  18:29:57  PAGE 17  

 00000086  5488      STRB        R0,[R1,R2]
  245:         counter--;
 00000088  3C01      SUB         R4,#0x1
  246:         Delay2();
 0000008A  F7FF      BL          Delay2?T  ; T=0x0001  (1)
 0000008C  FFB9      BL          Delay2?T  ; T=0x0001  (2)
  247:     }
 0000008E  1C20      MOV         R0,R4 ; counter
 00000090  2800      CMP         R0,#0x0 ; counter
 00000092  D1C7      BNE         L_100  ; T=0x00000024
  248:     display("SCN_COMPL");
 00000094  4800      LDR         R0,=??S_3 ; ??S_3
 00000096  F7FF      BL          display?T  ; T=0x0001  (1)
 00000098  FFB3      BL          display?T  ; T=0x0001  (2)
  249:     Delay();
 0000009A  F7FF      BL          Delay?T  ; T=0x0001  (1)
 0000009C  FFB1      BL          Delay?T  ; T=0x0001  (2)
  250:     Delay();
 0000009E  F7FF      BL          Delay?T  ; T=0x0001  (1)
 000000A0  FFAF      BL          Delay?T  ; T=0x0001  (2)
  251:     Delay();
 000000A2  F7FF      BL          Delay?T  ; T=0x0001  (1)
 000000A4  FFAD      BL          Delay?T  ; T=0x0001  (2)
  252:     display(vals);
 000000A6  A801      ADD         R0,R13,#0x4
 000000A8  F7FF      BL          display?T  ; T=0x0001  (1)
 000000AA  FFAA      BL          display?T  ; T=0x0001  (2)
  253:     return 0;
 000000AC  2000      MOV         R0,#0x0
 000000AE            ; SCOPE-END
 000000AE  B004      ADD         R13,#0x10
 000000B0  BC08      POP         {R3}
 000000B2  4718      BX          R3
 000000B4          ENDP ; 'main'



Module Information          Static
----------------------------------
  code size            =    ------
  data size            =         4
  const size           =        30
End of Module Information.


ARM COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
